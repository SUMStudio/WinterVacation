# Day 15 虚拟机2 函数调用命令

今天我们对我们的 VM 虚拟机进行进一步的完善。我们的 VM 虚拟机将支持整个目录编译，并且支持一系列函数调用命令。

## 基础知识

在 VM 虚拟机中，关于函数调用一共有三个命令

* `call f n` 跳转去执行一个含有 n 个参数的函数 f

  要注意的是，执行这条命令之前，我们必须保证，当前全局栈顶部的前 n 个元素，全部是函数 f 的参数，也就是说，这条 call 指令执行完之后，栈顶的前 n 个元素都会出栈

* `functiion f k` 声明一个有 k 个局部变量的函数 f

  要注意的是，这里的 k 并不是 f 的参数个数，而是为了执行这个函数 f，需要的额外的局部变量的个数，也就是 local 变量的个数

* `return ` 从当前函数返回，继续执行调用这个函数的函数

  注意，书中 p163 页的表格中，return 指令书写有误，VM 虚拟机的指令标签全部都是小写

函数，是对计算机指令的一种拓展，我们将一段代码封装到一个函数中，从此便不再关注这个函数的内部细节，我们只在乎函数给我们提供的**接口**，就 VM 虚拟机而言，调用一个函数，我们只在乎它从栈顶取走了几个元素，又放回栈顶几个元素，而发起 call 命令的函数，应该看不到他调用的函数的任何内部细节，也不受其的任何影响。也就是说，除了全局栈能改变外，其他的任何字段（LCL、ARG、THIS、THAT）不应该有任何的改变。

而我们如何能实现这一点？最简单最快捷的方法，就是重新找一块内存空间，把 LCL、ARG 等的基地址，映射到这块内存空间上。由于函数遵循后进先出原则，因此，我们的主栈空间，就能很好的满足要求。

但是，现在还有一个问题，我们的 return 命令是无状态的，为了能够返回到原来的函数中去，我们还得把原来函数的执行状态进行保存。

## call 命令的实现

把大象装进冰箱需要几步，执行一个 call命令就需要几步。

![call 命令][2]

1. 我们需要设置参数基地址
2. 保存当前函数的状态
3. 执行 goto 指令，跳转到目标函数执行语句中

参数的基地址不难确定，就是当前栈顶指针减去参数个数。怎样保存函数当前的状态呢？我们只需要保存当前函数的各个内存字段的基地址就好，而在生成了 goto 指令之后，我们还需要生成一个跳转的标签，保证调用函数执行完之后，还能返回到当前位置继续执行后续的代码。

```
@return-address
D=A
@SP
AM=M+1
A=A-1
M=D
//push rerturn-address
@LCL
D=M
@SP
AM=M+1
A=A-1
M=D
//push LCL
@ARG
D=M
@SP
AM=M+1
A=A-1
M=D
//push ARG
@THIS
D=M
@SP
AM=M+1
A=A-1
M=D
//push THIS
@THAT
D=M
@SP
AM=M+1
A=A-1
M=D
//push THAT
@SP
D=A
@n
D=D-A
@5
D=D-A
@ARG
M=D
//ARG=SP-n-5
@SP
D=M
@LCL
M=D
//LCL=SP
@functionName
0;JMP
//goto f
(return-address)
```

emmm, 好像很长的样子

## function 命令的实现

由于各个内存段基地址的初始化工作都在 call 命令中实现，function 命令需要做的就是声明一个入口标签，然后对局部变量进行初始化，仅此而已：

```
(functionName)
for(;k>0;k--)
	@SP
	AM=M+1
	M=0
```

## return 命令的实现

return 时涉及到原先函数状态的复原，命令也会稍有复杂

```
@SP
AM=M-1
D=M
@ARG
M=D
//重置调用者的返回值
@ARG
D=A
@SP
M=D+1
//恢复调用者的 SP
@LCL
D=M
@1
A=D-A
D=M
@THAT
M=D
//恢复THAT
@LCL
D=M
@2
A=D-A
D=M
@THIS
M=D
//恢复THIS
@LCL
D=M
@3
A=D-A
D=M
@ARG
M=D
//恢复ARG
@LCL
D=M
@4
A=D-A
D=M
@LCL
M=D
//恢复LCL
D=A
@5
A=D-A
A=M
0;JMP
//跳回返回地址
```

就这样了，再把 Praser 里的 commandType 修改一下，就可以了

接下来，我们要实现整个文件夹的编译